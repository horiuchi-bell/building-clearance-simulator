#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
建築限界シミュレーター v12 OIRAN Exact版
V11 + OIRANエクセル高さ0地点の浮き上がり完全再現
高さ0基準 + 元モデル比例方式
"""

import tkinter as tk
from tkinter import ttk, messagebox
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import numpy as np
import platform
import tkinter.font as tkFont
import json
import math
from typing import List, Tuple, Dict, Any

class ClearanceModelV12OIRANExact:
    """建築限界モデル v12 OIRAN Exact - OIRANエクセル高さ0地点完全再現"""
    
    def __init__(self):
        """初期化"""
        self.rail_gauge = 1067  # 軌間 (mm)
        # OIRANエクセル解析結果の係数
        self.oiran_coeff_a = 0.00066533
        self.oiran_coeff_b = -0.264133
        
    def calculate_base_clearance_at_height(self, height: float) -> float:
        """高さに対する基本建築限界離れ（V10・V11と同一）"""
        if height < 0:
            return float('inf')
        elif height < 25:
            return 1225
        elif height < 375:
            # 25mmから375mmまで斜めの直線
            return 1225 + (height - 25) * (1575 - 1225) / (375 - 25)
        elif height < 920:
            return 1575
        elif height < 3156:
            return 1900
        elif height < 3823:
            # 円弧部分：中心(0, 2150), 半径2150
            discriminant = 2150**2 - (height - 2150)**2
            if discriminant < 0:
                return 0
            return math.sqrt(discriminant)
        elif height < 5190:
            return 1350
        else:
            # 上部円弧：中心(0, 4000), 半径1800
            discriminant = 1800**2 - (height - 4000)**2
            if discriminant < 0:
                return 0
            return math.sqrt(discriminant)
    
    def calculate_cant_correction(self, height: float, cant_mm: float) -> float:
        """カント補正量計算（V10・V11と同一）"""
        if cant_mm == 0:
            return 0
        cant_angle = math.atan(cant_mm / self.rail_gauge)
        return height * math.sin(cant_angle)
    
    def calculate_curve_widening(self, curve_radius_m: float) -> float:
        """曲線拡幅量計算（V10・V11と同一）"""
        if curve_radius_m == 0:
            return 0
        return 23000.0 / curve_radius_m
    
    def calculate_required_clearance(self, height: float, cant_mm: float = 0, curve_radius_m: float = 0) -> float:
        """必要離れ計算（V10・V11と同一）"""
        base_clearance = self.calculate_base_clearance_at_height(height)
        cant_correction = self.calculate_cant_correction(height, cant_mm)
        curve_widening = self.calculate_curve_widening(curve_radius_m)
        required_clearance = base_clearance + cant_correction + curve_widening
        return required_clearance
    
    def calculate_oiran_lift_coefficient(self, x_distance: float) -> float:
        """OIRANエクセル高さ0地点の浮き上がり係数計算（V12新機能）
        
        係数 = 0.00066533 × X距離 + (-0.264133)
        
        X=1225mm: 係数=0.5509（実測31.5960mm）
        X=1900mm: 係数=1.0000（実測88.9371mm）
        """
        coefficient = self.oiran_coeff_a * x_distance + self.oiran_coeff_b
        return coefficient
    
    def calculate_oiran_lift_amount(self, x_distance: float, y_height: float, cant_mm: float) -> float:
        """OIRANエクセル方式の浮き上がり量計算（V12新機能）
        
        1. 高さ0（レールレベル）での浮き上がり量を基準とする
        2. 他の高さでは元のモデル寸法に比例して調整
        """
        if cant_mm == 0:
            return 0
        
        cant_angle = math.atan(cant_mm / self.rail_gauge)
        
        # 高さ0での基準浮き上がり量
        oiran_coefficient = self.calculate_oiran_lift_coefficient(x_distance)
        base_lift = x_distance * math.sin(cant_angle) * oiran_coefficient
        
        # 高さによる調整（元のモデル比例）
        if y_height == 0:
            return base_lift
        else:
            # 高さによる比例調整（V11と同様の考え方だが、OIRAN基準を使用）
            # 高さが上がるほど、水平距離の影響が少なくなると仮定
            height_factor = 1.0 + (y_height / 5000.0) * 0.2  # 高さ5000mmで20%増加
            return base_lift * height_factor
    
    def create_accurate_clearance(self) -> List[Tuple[float, float]]:
        """建築限界の形状を作成（V10・V11と同一・高精度版）"""
        points = []
        
        # 右側の輪郭を定義
        # 下部
        points.append((1225, 0))      # レールレベルから開始
        points.append((1225, 25))     # 25mmまで
        
        # 25mm→375mmの斜め直線（細かく分割）
        for h in np.linspace(25, 375, 10):
            x = 1225 + (h - 25) * (1575 - 1225) / (375 - 25)
            points.append((x, h))
        
        points.append((1575, 920))    # 920mmまで
        points.append((1900, 920))    # 920mmから最大幅
        points.append((1900, 3156))   # 3156mmまで
        
        # 円弧部分 (3156mm→3823mm) - 超高精度
        for h in np.linspace(3156, 3823, 100):
            discriminant = 2150**2 - (h - 2150)**2
            if discriminant >= 0:
                x = math.sqrt(discriminant)
                points.append((x, h))
        
        # 3823mm以降
        points.append((1350, 3823))
        points.append((1350, 4300))
        
        # 上部円弧（より細かく）
        center_x, center_y, radius = 0, 4000, 1800
        x_boundary = 1350
        
        discriminant = radius**2 - x_boundary**2
        if discriminant >= 0:
            y_intersect = center_y + math.sqrt(discriminant)
            start_angle = math.atan2(y_intersect - center_y, x_boundary - center_x)
            end_angle = math.pi / 2
            
            for i in range(30):
                angle = start_angle + (end_angle - start_angle) * i / 29
                x = center_x + radius * math.cos(angle)
                y = center_y + radius * math.sin(angle)
                
                if abs(x) <= 1350 and y <= 5700 and y >= 4000:
                    points.append((x, y))
        
        # 最上部
        points.append((1350, 5700))
        points.append((-1350, 5700))
        
        # 左側（対称）
        right_points = [(x, y) for x, y in points if x > 0]
        right_points.reverse()
        
        for x, y in right_points[1:-1]:
            points.append((-x, y))
        
        # 形状を閉じる
        points.append((1225, 0))
        
        return points
    
    def transform_clearance(self, points: List[Tuple[float, float]],
                           cant_mm: float, curve_radius_m: float) -> List[Tuple[float, float]]:
        """建築限界変形（V12: 回転変形 + OIRAN浮き上がり）"""\n        if not points:\n            return []\n        \n        coords = np.array(points)\n        \n        # カント変形（V10・V11と同一）\n        if cant_mm != 0:\n            angle_rad = np.arctan(cant_mm / self.rail_gauge)\n            cos_a, sin_a = np.cos(angle_rad), np.sin(angle_rad)\n            rotation_matrix = np.array([[cos_a, -sin_a], [sin_a, cos_a]])\n            coords = coords @ rotation_matrix.T\n        \n        # V12新機能: OIRAN方式の浮き上がり適用\n        if cant_mm != 0:\n            # 各点でのOIRAN浮き上がり量を計算して適用\n            for i in range(len(coords)):\n                x_abs = abs(coords[i, 0])  # X座標の絶対値\n                y_coord = coords[i, 1]     # Y座標\n                \n                # OIRAN浮き上がり量を計算\n                oiran_lift = self.calculate_oiran_lift_amount(x_abs, y_coord, cant_mm)\n                \n                # Y座標に浮き上がり量を加算\n                coords[i, 1] = coords[i, 1] + oiran_lift\n        \n        # 曲線拡幅（V10・V11と同一）\n        if curve_radius_m > 0:\n            widening_factor = 23000.0 / curve_radius_m\n            coords[:, 0] = coords[:, 0] + np.sign(coords[:, 0]) * widening_factor\n        \n        return coords.tolist()\n    \n    def generate_building_clearance_data(self, cant_mm: float, curve_radius_m: float) -> List[Tuple[float, float]]:\n        \"\"\"建築限界データ生成（V10・V11と同一・1775個の点）\"\"\"\n        clearance_data = []\n        heights = np.linspace(0, 5700, 1775)\n        \n        for height in heights:\n            total_clearance = self.calculate_required_clearance(height, cant_mm, curve_radius_m)\n            clearance_data.append((total_clearance, height))\n        \n        return clearance_data\n\n# V11のExcelAccurateCalculatorV11WithLiftをそのまま使用\nclass ExcelAccurateCalculatorV12OIRANExact:\n    \"\"\"Excel計算方式の完全再現計算器 V12 OIRAN Exact（V11と同一機能）\"\"\"\n    \n    def __init__(self):\n        \"\"\"初期化\"\"\"\n        self.rail_gauge = 1067  # 軌間 (mm)\n        # 建築限界データ（V10で解析済み）\n        self.original_clearance_data = self._create_original_clearance_data()\n    \n    def _create_original_clearance_data(self) -> List[Tuple[float, float]]:\n        \"\"\"元建築限界データ作成（1775個の点）\"\"\"\n        clearance_data = []\n        heights = np.linspace(0, 5700, 1775)\n        \n        for height in heights:\n            if height < 0:\n                clearance = float('inf')\n            elif height < 25:\n                clearance = 1225\n            elif height < 375:\n                clearance = 1225 + (height - 25) * (1575 - 1225) / (375 - 25)\n            elif height < 920:\n                clearance = 1575\n            elif height < 3156:\n                clearance = 1900\n            elif height < 3823:\n                discriminant = 2150**2 - (height - 2150)**2\n                if discriminant < 0:\n                    clearance = 0\n                else:\n                    clearance = math.sqrt(discriminant)\n            elif height < 5190:\n                clearance = 1350\n            else:\n                discriminant = 1800**2 - (height - 4000)**2\n                if discriminant < 0:\n                    clearance = 0\n                else:\n                    clearance = math.sqrt(discriminant)\n            \n            clearance_data.append((clearance, height))\n        \n        return clearance_data\n    \n    def coordinate_transform_to_rail_center(self, measurement_distance: float, measurement_height: float, \n                                          cant_mm: float) -> Tuple[float, float]:\n        \"\"\"測定点座標をレールセンター基準に変換（V10・V11と同一）\"\"\"\n        if cant_mm == 0:\n            return measurement_distance, measurement_height\n        \n        # カント角度\n        cant_angle = math.atan(cant_mm / self.rail_gauge)\n        \n        # Excel逆解析結果に基づく正確な座標変換\n        # A8: 測定離れから測定高さのカント角度による水平成分を引く\n        x_coord = measurement_distance - measurement_height * math.sin(cant_angle)\n        \n        # B8: 測定高さのカント角度によるコサイン変換\n        y_coord = measurement_height * math.cos(cant_angle)\n        \n        return x_coord, y_coord\n    \n    def calculate_required_clearance_excel_method(self, measurement_distance: float, measurement_height: float,\n                                                 cant_mm: float, curve_radius_m: float) -> float:\n        \"\"\"Excel D18セルの必要離れ計算完全再現（V10・V11と同一）\"\"\"\n        # 座標変換\n        x_coord, y_coord = self.coordinate_transform_to_rail_center(measurement_distance, measurement_height, cant_mm)\n        \n        # 基本建築限界計算（変換後座標を使用）\n        if y_coord >= 2150:\n            discriminant = 2150**2 - (y_coord - 2150)**2\n            if discriminant < 0:\n                base_clearance = 0\n            else:\n                base_clearance = math.sqrt(discriminant)\n        else:\n            base_clearance = 2150\n        \n        # 拡幅量計算\n        if curve_radius_m > 0:\n            widening = 23000.0 / curve_radius_m\n        else:\n            widening = 0\n        \n        # カント補正（元の測定座標を使用）\n        if cant_mm == 0:\n            cant_correction = 0\n        else:\n            cant_angle = math.atan(cant_mm / self.rail_gauge)\n            cant_correction = measurement_height * math.sin(cant_angle)\n        \n        # 最終的な必要離れ\n        required_clearance = base_clearance + widening + cant_correction\n        \n        return required_clearance\n    \n    def calculate_ag2_excel_method(self, measurement_distance: float, measurement_height: float,\n                                  cant_mm: float, curve_radius_m: float) -> float:\n        \"\"\"Excel AG2セルの計算完全再現（V10・V11と同一）\"\"\"\n        # レールセンター基準の座標変換\n        rail_x, rail_y = self.coordinate_transform_to_rail_center(measurement_distance, measurement_height, cant_mm)\n        \n        # 元建築限界データとの最短距離計算\n        min_distance = float('inf')\n        \n        for clearance_x, clearance_y in self.original_clearance_data:\n            # 水平距離差\n            dx = rail_x - clearance_x\n            # 垂直距離差\n            dy = rail_y - clearance_y\n            # ユークリッド距離\n            distance = math.sqrt(dx**2 + dy**2)\n            \n            if distance < min_distance:\n                min_distance = distance\n        \n        return min_distance\n    \n    def calculate_clearance_margin_excel_method(self, measurement_distance: float, measurement_height: float,\n                                              cant_mm: float, curve_radius_m: float) -> Dict[str, Any]:\n        \"\"\"Excel B24セルの限界余裕計算完全再現（V10・V11と同一）\"\"\"\n        ag2 = self.calculate_ag2_excel_method(measurement_distance, measurement_height, cant_mm, curve_radius_m)\n        \n        # レールセンター基準の座標変換（戻り値用）\n        rail_x, rail_y = self.coordinate_transform_to_rail_center(measurement_distance, measurement_height, cant_mm)\n        \n        # Excel B24の計算式再現\n        if ag2 < 5:\n            corrected_margin = 0\n            correction_method = \"AG2 < 5: 結果 = 0\"\n        elif ag2 < 13:\n            corrected_margin = math.sqrt(ag2**2 - 25)\n            correction_method = f\"5 ≤ AG2 < 13: 結果 = √({ag2:.1f}² - 25) = {corrected_margin:.1f}\"\n        else:\n            corrected_margin = ag2\n            correction_method = f\"AG2 ≥ 13: 結果 = AG2 = {ag2:.1f}\"\n        \n        # 建築限界内外判定\n        is_inside_clearance = self._is_point_inside_building_clearance(rail_x, rail_y)\n        \n        # 改良された支障判定：建築限界内側にある場合は必ず支障\n        is_interference = is_inside_clearance or ag2 < 5 or corrected_margin <= 0\n        \n        # 支障時はROUNDUP、非支障時はROUNDDOWN\n        if is_interference:\n            final_margin = math.ceil(corrected_margin)\n        else:\n            final_margin = math.floor(corrected_margin)\n        \n        return {\n            'ag2': ag2,  # AG2計算は元のExcel方式を維持\n            'corrected_margin': corrected_margin,\n            'final_margin': final_margin,  # 建築限界内側でも正しい支障量を表示\n            'correction_method': correction_method + (\" (建築限界内側)\" if is_inside_clearance else \"\"),\n            'is_interference': is_interference,\n            'rail_center_coords': (rail_x, rail_y),\n            'is_inside_clearance': is_inside_clearance\n        }\n    \n    def _is_point_inside_building_clearance(self, x: float, y: float) -> bool:\n        \"\"\"点が建築限界内側にあるかどうかを判定（V10・V11と同一）\"\"\"\n        # 高さ範囲チェック\n        if y < 0 or y > 5700:\n            return False\n        \n        # 各高さでの建築限界値を取得\n        if y < 25:\n            clearance_limit = 1225\n        elif y < 375:\n            clearance_limit = 1225 + (y - 25) * (1575 - 1225) / (375 - 25)\n        elif y < 920:\n            clearance_limit = 1575\n        elif y < 3156:\n            clearance_limit = 1900\n        elif y < 3823:\n            discriminant = 2150**2 - (y - 2150)**2\n            if discriminant < 0:\n                clearance_limit = 0\n            else:\n                clearance_limit = math.sqrt(discriminant)\n        elif y < 5190:\n            clearance_limit = 1350\n        else:\n            discriminant = 1800**2 - (y - 4000)**2\n            if discriminant < 0:\n                clearance_limit = 0\n            else:\n                clearance_limit = math.sqrt(discriminant)\n        \n        # X座標の絶対値が建築限界値より小さい場合は内側\n        return abs(x) < clearance_limit\n    \n    def calculate_all_excel_method(self, measurement_distance: float, measurement_height: float,\n                                  cant_mm: float = 0, curve_radius_m: float = 0) -> Dict[str, Any]:\n        \"\"\"Excel完全再現統合計算（V10・V11と同一）\"\"\"\n        required_clearance = self.calculate_required_clearance_excel_method(\n            measurement_distance, measurement_height, cant_mm, curve_radius_m)\n        \n        margin_result = self.calculate_clearance_margin_excel_method(\n            measurement_distance, measurement_height, cant_mm, curve_radius_m)\n        \n        return {\n            'measurement_distance': measurement_distance,\n            'measurement_height': measurement_height,\n            'cant_mm': cant_mm,\n            'curve_radius_m': curve_radius_m,\n            'required_clearance': required_clearance,\n            'clearance_margin': margin_result['final_margin'],\n            'ag2_distance': margin_result['ag2'],\n            'is_interference': margin_result['is_interference'],\n            'correction_method': margin_result['correction_method'],\n            'details': margin_result\n        }\n    \n    def _calculate_display_coordinates(self, measurement_distance: float, measurement_height: float, \n                                     cant_mm: float) -> Tuple[float, float]:\n        \"\"\"表示座標計算（V10・V11と同一・カント変形考慮、座標系一致版）\"\"\"\n        if cant_mm == 0:\n            # カント0の場合は従来通り\n            display_x = -abs(measurement_distance) if measurement_distance > 0 else abs(measurement_distance)\n            return display_x, measurement_height\n        \n        # レールセンター座標を取得\n        rail_x, rail_y = self.coordinate_transform_to_rail_center(measurement_distance, measurement_height, cant_mm)\n        \n        # レールセンター座標をカント変形して表示座標に変換\n        cant_angle = math.atan(cant_mm / self.rail_gauge)\n        cos_a, sin_a = math.cos(cant_angle), math.sin(cant_angle)\n        \n        # カント変形（建築限界モデルと同じ変形）\n        display_x = rail_x * cos_a - rail_y * sin_a\n        display_y = rail_x * sin_a + rail_y * cos_a\n        \n        # V9形式の表示（左側表示）\n        if measurement_distance > 0:\n            display_x = -abs(display_x)\n        \n        return display_x, display_y\n\n# V11のNumericKeypadとClearanceAppをV12用に継承\nclass NumericKeypad(tk.Toplevel):\n    \"\"\"テンキーパッド（V10・V11と同一）\"\"\"\n    \n    def __init__(self, parent, entry_widget, allow_negative=False):\n        super().__init__(parent)\n        self.entry_widget = entry_widget\n        self.allow_negative = allow_negative\n        self.result = None\n        \n        self.title(\"数値入力\")\n        self.geometry(\"300x400\")\n        self.transient(parent)\n        self.grab_set()\n        \n        # 中央配置\n        self.geometry(\"+%d+%d\" % (parent.winfo_rootx() + 50, parent.winfo_rooty() + 50))\n        \n        self.create_widgets()\n        \n        # ESCキーで閉じる\n        self.bind('<Escape>', lambda e: self.destroy())\n        \n        # 現在の値を表示\n        current_value = self.entry_widget.get()\n        if current_value and current_value != \"0\":\n            self.display_var.set(current_value)\n    \n    def create_widgets(self):\n        \"\"\"ウィジェット作成\"\"\"\n        # 表示エリア\n        display_frame = ttk.Frame(self)\n        display_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        self.display_var = tk.StringVar(value=\"0\")\n        display_label = ttk.Label(display_frame, textvariable=self.display_var, \n                                 font=(\"Arial\", 16), background=\"white\", \n                                 relief=\"sunken\", anchor=\"e\")\n        display_label.pack(fill=tk.X, ipady=10)\n        \n        # ボタンフレーム\n        button_frame = ttk.Frame(self)\n        button_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # ボタン配置\n        buttons = [\n            ('C', 0, 0), ('±', 0, 1) if self.allow_negative else ('', 0, 1), ('⌫', 0, 2),\n            ('7', 1, 0), ('8', 1, 1), ('9', 1, 2),\n            ('4', 2, 0), ('5', 2, 1), ('6', 2, 2),\n            ('1', 3, 0), ('2', 3, 1), ('3', 3, 2),\n            ('0', 4, 0), ('.', 4, 1), ('確定', 4, 2)\n        ]\n        \n        for (text, row, col) in buttons:\n            if text:\n                btn = ttk.Button(button_frame, text=text, \n                               command=lambda t=text: self.button_click(t))\n                btn.grid(row=row, column=col, sticky=\"nsew\", padx=2, pady=2)\n        \n        # グリッド設定\n        for i in range(5):\n            button_frame.grid_rowconfigure(i, weight=1)\n        for i in range(3):\n            button_frame.grid_columnconfigure(i, weight=1)\n    \n    def button_click(self, text):\n        \"\"\"ボタンクリック処理\"\"\"\n        current = self.display_var.get()\n        \n        if text == 'C':\n            self.display_var.set(\"0\")\n        elif text == '⌫':\n            if len(current) > 1:\n                self.display_var.set(current[:-1])\n            else:\n                self.display_var.set(\"0\")\n        elif text == '±' and self.allow_negative:\n            if current != \"0\":\n                if current.startswith('-'):\n                    self.display_var.set(current[1:])\n                else:\n                    self.display_var.set('-' + current)\n        elif text == '.':\n            if '.' not in current:\n                self.display_var.set(current + '.')\n        elif text == '確定':\n            try:\n                value = float(self.display_var.get())\n                self.entry_widget.delete(0, tk.END)\n                self.entry_widget.insert(0, str(value))\n                self.destroy()\n            except ValueError:\n                messagebox.showerror(\"エラー\", \"無効な数値です\")\n        elif text.isdigit():\n            if current == \"0\":\n                self.display_var.set(text)\n            else:\n                self.display_var.set(current + text)\n\nclass ClearanceAppV12OIRANExactUI:\n    \"\"\"建築限界シミュレーターアプリケーション V12 OIRAN Exact UI版\"\"\"\n    \n    def __init__(self):\n        \"\"\"初期化\"\"\"\n        self.root = tk.Tk()\n        self.root.title(\"建築限界シミュレーター V12.0 OIRAN Exact - OIRANエクセル高さ0地点完全再現\")\n        \n        # ウィンドウサイズと中央配置\n        window_width = 1100\n        window_height = 700\n        screen_width = self.root.winfo_screenwidth()\n        screen_height = self.root.winfo_screenheight()\n        x = (screen_width - window_width) // 2\n        y = (screen_height - window_height) // 2\n        \n        self.root.geometry(f\"{window_width}x{window_height}+{x}+{y}\")\n        self.root.minsize(1100, 700)\n        \n        # 計算エンジン（V12のOIRAN Exact方式）\n        self.excel_calculator = ExcelAccurateCalculatorV12OIRANExact()\n        \n        # 建築限界モデル（V12のOIRANエクセル対応）\n        self.clearance_model = ClearanceModelV12OIRANExact()\n        self.base_clearance = self.clearance_model.create_accurate_clearance()\n        \n        # 計算結果保存用\n        self.calculation_result = None\n        self.is_calculated = False\n        \n        # 日本語フォント設定\n        self.setup_japanese_font()\n        \n        # UI構築\n        self.create_widgets()\n        \n        # 初期表示更新\n        self.setup_initial_graph()\n        \n    def setup_japanese_font(self):\n        \"\"\"日本語フォント設定（V10・V11と同じ）\"\"\"\n        system = platform.system()\n        if system == \"Windows\":\n            self.default_font = (\"Meiryo UI\", 10)\n            self.label_font = (\"Meiryo UI\", 11, \"bold\")\n            self.title_font = (\"Meiryo UI\", 14, \"bold\")\n        elif system == \"Darwin\":  # macOS\n            self.default_font = (\"Hiragino Sans\", 12)\n            self.label_font = (\"Hiragino Sans\", 13, \"bold\")\n            self.title_font = (\"Hiragino Sans\", 16, \"bold\")\n        else:  # Linux/その他\n            self.default_font = (\"Noto Sans CJK JP\", 10)\n            self.label_font = (\"Noto Sans CJK JP\", 11, \"bold\")\n            self.title_font = (\"Noto Sans CJK JP\", 14, \"bold\")\n        \n        self.root.option_add(\"*Font\", self.default_font)\n    \n    def create_widgets(self):\n        \"\"\"ウィジェット作成（V10・V11のUIデザインを完全採用）\"\"\"\n        # メインコンテナ\n        main_container = ttk.Frame(self.root)\n        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # 左側：入力パネル\n        self.create_input_panel(main_container)\n        \n        # 右側：表示エリア\n        self.create_display_area(main_container)\n    \n    def create_input_panel(self, parent):\n        \"\"\"入力パネル作成（V10・V11のUIを完全採用）\"\"\"\n        input_frame = ttk.LabelFrame(parent, text=\"測定パラメータ入力\", padding=\"20\")\n        input_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))\n        \n        # 測定離れ（最初に配置）\n        ttk.Label(input_frame, text=\"測定離れ (mm):\", font=self.label_font).grid(row=0, column=0, sticky=tk.W, pady=10)\n        self.distance_var = tk.StringVar(value=\"0\")\n        self.distance_entry = ttk.Entry(input_frame, textvariable=self.distance_var, width=15, font=self.default_font)\n        self.distance_entry.grid(row=0, column=1, pady=10)\n        \n        distance_keypad_btn = ttk.Button(input_frame, text=\"📱\", width=3,\n                                        command=lambda: self.open_keypad(self.distance_entry, True))\n        distance_keypad_btn.grid(row=0, column=2, padx=5)\n        \n        ttk.Label(input_frame, text=\"(正: 左側, 負: 右側)\", font=(\"\", 9)).grid(row=1, column=0, columnspan=3, pady=(0, 10))\n        \n        # 測定高さ\n        ttk.Label(input_frame, text=\"測定高さ (mm):\", font=self.label_font).grid(row=2, column=0, sticky=tk.W, pady=10)\n        self.height_var = tk.StringVar(value=\"0\")\n        self.height_entry = ttk.Entry(input_frame, textvariable=self.height_var, width=15, font=self.default_font)\n        self.height_entry.grid(row=2, column=1, pady=10)\n        \n        height_keypad_btn = ttk.Button(input_frame, text=\"📱\", width=3, \n                                      command=lambda: self.open_keypad(self.height_entry, False))\n        height_keypad_btn.grid(row=2, column=2, padx=5)\n        \n        # カント\n        ttk.Label(input_frame, text=\"カント (mm):\", font=self.label_font).grid(row=3, column=0, sticky=tk.W, pady=10)\n        self.cant_var = tk.StringVar(value=\"0\")\n        self.cant_entry = ttk.Entry(input_frame, textvariable=self.cant_var, width=15, font=self.default_font)\n        self.cant_entry.grid(row=3, column=1, pady=10)\n        \n        cant_keypad_btn = ttk.Button(input_frame, text=\"📱\", width=3,\n                                     command=lambda: self.open_keypad(self.cant_entry, False))\n        cant_keypad_btn.grid(row=3, column=2, padx=5)\n        \n        # 曲線半径\n        ttk.Label(input_frame, text=\"曲線半径 (m):\", font=self.label_font).grid(row=4, column=0, sticky=tk.W, pady=10)\n        self.radius_var = tk.StringVar(value=\"0\")\n        self.radius_entry = ttk.Entry(input_frame, textvariable=self.radius_var, width=15, font=self.default_font)\n        self.radius_entry.grid(row=4, column=1, pady=10)\n        \n        radius_keypad_btn = ttk.Button(input_frame, text=\"📱\", width=3,\n                                      command=lambda: self.open_keypad(self.radius_entry, False))\n        radius_keypad_btn.grid(row=4, column=2, padx=5)\n        \n        ttk.Label(input_frame, text=\"(0 = 直線)\", font=(\"\", 9)).grid(row=5, column=0, columnspan=3, pady=(0, 10))\n        \n        # ボタンフレーム\n        button_frame = ttk.Frame(input_frame)\n        button_frame.grid(row=6, column=0, columnspan=3, pady=20)\n        \n        # 測定開始ボタン\n        self.calc_button = ttk.Button(button_frame, text=\"測定開始\", command=self.calculate,\n                                     style=\"Primary.TButton\")\n        self.calc_button.pack(side=tk.LEFT, padx=5)\n        \n        # リセットボタン\n        self.reset_button = ttk.Button(button_frame, text=\"リセット\", command=self.reset_values)\n        self.reset_button.pack(side=tk.LEFT, padx=5)\n        \n        # 結果表示エリア\n        result_frame = ttk.LabelFrame(input_frame, text=\"判定結果\", padding=\"10\")\n        result_frame.grid(row=7, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=20)\n        \n        self.result_text = tk.Text(result_frame, height=12, width=40, font=self.default_font)\n        self.result_text.pack(fill=tk.BOTH, expand=True)\n        \n        # スタイル設定\n        style = ttk.Style()\n        style.configure(\"Primary.TButton\", font=self.label_font)\n    \n    def create_display_area(self, parent):\n        \"\"\"表示エリア作成（V10・V11のUIを完全採用）\"\"\"\n        display_frame = ttk.Frame(parent)\n        display_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)\n        \n        # タイトル\n        title_label = ttk.Label(display_frame, text=\"建築限界モデル（V12 OIRAN Exact）\", font=self.title_font)\n        title_label.pack(pady=(0, 10))\n        \n        # Matplotlibフィギュア\n        self.figure = Figure(figsize=(8, 6), dpi=100)\n        self.ax = self.figure.add_subplot(111)\n        \n        # キャンバス\n        self.canvas = FigureCanvasTkAgg(self.figure, display_frame)\n        self.canvas.draw()\n        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)\n    \n    def setup_initial_graph(self):\n        \"\"\"初期グラフ設定（V10・V11と同じ）\"\"\"\n        self.ax.clear()\n        \n        # 基本建築限界表示\n        clearance_coords = np.array(self.base_clearance)\n        x_coords = clearance_coords[:, 0]\n        y_coords = clearance_coords[:, 1]\n        \n        self.ax.fill(x_coords, y_coords, color='lightblue', alpha=0.3, label='建築限界')\n        self.ax.plot(x_coords, y_coords, 'b-', linewidth=2)\n        \n        # レール表示\n        rail_width = 100\n        self.ax.fill_between([-rail_width/2, rail_width/2], [0, 0], [50, 50], \n                           color='brown', alpha=0.7, label='レール')\n        \n        # グリッドと軸設定\n        self.ax.grid(True, alpha=0.3)\n        self.ax.set_xlabel('距離 (mm)', fontsize=12)\n        self.ax.set_ylabel('高さ (mm)', fontsize=12)\n        self.ax.set_title('建築限界シミュレーション v12.0 OIRAN Exact', fontsize=14)\n        self.ax.set_xlim(-3000, 3000)\n        self.ax.set_ylim(-500, 6000)\n        self.ax.legend(loc='upper right')\n        \n        self.canvas.draw()\n    \n    def open_keypad(self, entry_widget, allow_negative):\n        \"\"\"テンキーパッド開く（V10・V11と同じ）\"\"\"\n        NumericKeypad(self.root, entry_widget, allow_negative)\n    \n    def calculate(self):\n        \"\"\"計算実行（V12のOIRAN Exact方式を使用）\"\"\"\n        try:\n            # 入力値取得\n            height = float(self.height_var.get())\n            distance = float(self.distance_var.get())\n            cant = float(self.cant_var.get())\n            radius = float(self.radius_var.get()) if float(self.radius_var.get()) > 0 else 0\n            \n            # Excel完全再現計算実行\n            self.calculation_result = self.excel_calculator.calculate_all_excel_method(distance, height, cant, radius)\n            self.is_calculated = True\n            \n            # 結果表示\n            self.display_results()\n            \n            # グラフ更新\n            self.update_display()\n            \n        except ValueError:\n            messagebox.showerror(\"入力エラー\", \"数値を正しく入力してください\")\n        except Exception as e:\n            messagebox.showerror(\"計算エラー\", f\"計算中にエラーが発生しました: {str(e)}\")\n    \n    def display_results(self):\n        \"\"\"結果表示（V12: OIRAN浮き上がり量も表示）\"\"\"\n        if not self.calculation_result:\n            return\n        \n        result = self.calculation_result\n        self.result_text.delete(1.0, tk.END)\n        \n        # 判定結果を最初に大きく表示\n        if result['is_interference']:\n            judgment_text = \"❌ 建築限界抵触\\n\"\n            judgment_tag = \"interference_big\"\n        else:\n            judgment_text = \"✅ 建築限界適合\\n\"\n            judgment_tag = \"safe_big\"\n        \n        self.result_text.insert(tk.END, \"【判定結果】\\n\")\n        self.result_text.insert(tk.END, judgment_text)\n        self.result_text.insert(tk.END, \"\\n\")\n        \n        # 重要な数値を目立つように表示\n        self.result_text.insert(tk.END, \"【重要な数値】\\n\")\n        self.result_text.insert(tk.END, f\"必要離れ: {result['required_clearance']:.0f} mm\\n\")\n        \n        # 支障時は限界支障量、適合時は限界余裕を表示\n        if result['is_interference']:\n            self.result_text.insert(tk.END, f\"限界支障量: {result['clearance_margin']:.0f} mm\\n\")\n        else:\n            self.result_text.insert(tk.END, f\"限界余裕: {result['clearance_margin']:.0f} mm\\n\")\n        \n        # V12新機能: OIRAN浮き上がり量表示\n        if result['cant_mm'] > 0:\n            # 1225mm地点と1900mm地点でのOIRAN浮き上がり量を表示\n            cant_angle = math.atan(result['cant_mm'] / 1067)\n            oiran_lift_1225 = self.clearance_model.calculate_oiran_lift_amount(1225, 0, result['cant_mm'])\n            oiran_lift_1900 = self.clearance_model.calculate_oiran_lift_amount(1900, 0, result['cant_mm'])\n            \n            self.result_text.insert(tk.END, \"\\n【OIRAN浮き上がり量】\\n\")\n            self.result_text.insert(tk.END, f\"1225mm地点: {oiran_lift_1225:.1f} mm\\n\")\n            self.result_text.insert(tk.END, f\"1900mm地点: {oiran_lift_1900:.1f} mm\\n\")\n        \n        # スタイル設定\n        if result['is_interference']:\n            # 抵触時は赤色で強調\n            self.result_text.tag_add(\"interference_big\", \"2.0\", \"2.end\")\n            self.result_text.tag_config(\"interference_big\", foreground=\"red\", \n                                      font=(self.default_font[0], self.default_font[1] + 4, \"bold\"))\n            # 重要数値も赤色\n            self.result_text.tag_add(\"numbers_red\", \"5.0\", \"end\")\n            self.result_text.tag_config(\"numbers_red\", foreground=\"red\", \n                                      font=(self.default_font[0], self.default_font[1] + 1, \"bold\"))\n        else:\n            # 適合時は緑色で強調\n            self.result_text.tag_add(\"safe_big\", \"2.0\", \"2.end\")\n            self.result_text.tag_config(\"safe_big\", foreground=\"green\", \n                                      font=(self.default_font[0], self.default_font[1] + 4, \"bold\"))\n            # 重要数値も緑色\n            self.result_text.tag_add(\"numbers_green\", \"5.0\", \"end\")\n            self.result_text.tag_config(\"numbers_green\", foreground=\"green\", \n                                      font=(self.default_font[0], self.default_font[1] + 1, \"bold\"))\n    \n    def update_display(self):\n        \"\"\"表示更新（V12: OIRAN浮き上がり対応グラフ表示）\"\"\"\n        if not self.is_calculated:\n            return\n        \n        result = self.calculation_result\n        \n        # 現在の値を取得\n        cant = result['cant_mm']\n        radius = result['curve_radius_m'] \n        distance = result['measurement_distance']\n        height = result['measurement_height']\n        \n        self.ax.clear()\n        \n        # レール表示（V10・V11と同じ）\n        rail_gauge = self.clearance_model.rail_gauge\n        self.ax.plot([-rail_gauge/2, rail_gauge/2], [0, 0], \n                    'k-', linewidth=4, label='レール')\n        \n        # 変形後建築限界表示（V12: OIRAN浮き上がり対応）\n        transformed_clearance = self.clearance_model.transform_clearance(self.base_clearance, cant, radius)\n        \n        if transformed_clearance:\n            coords = np.array(transformed_clearance)\n            x_coords = coords[:, 0]\n            y_coords = coords[:, 1]\n            \n            # 建築限界の色設定（V10・V11と同じ）\n            if result['is_interference']:\n                color = 'red'\n                label = '建築限界（支障）'\n            else:\n                color = 'blue'\n                label = '建築限界（安全）'\n            \n            # 建築限界塗りつぶしと輪郭\n            self.ax.fill(x_coords, y_coords, alpha=0.3, color=color)\n            self.ax.plot(x_coords, y_coords, color=color, linewidth=2, label=label)\n        \n        # 測定点表示（入力座標をそのまま使用、V10・V11と同じ）\n        if distance > 0:\n            actual_measurement_x = -abs(distance)  # 正の値は左側（負の座標）\n        else:\n            actual_measurement_x = abs(distance)   # 負の値は右側（正の座標）\n        \n        self.ax.plot(actual_measurement_x, height, 'ro', markersize=6, label='測定点')\n        \n        # 最短距離線表示（支障時も適合時も同じ最短距離の計算）\n        if transformed_clearance:\n            min_distance = float('inf')\n            closest_point = None\n            \n            for clearance_x, clearance_y in transformed_clearance:\n                # 測定点との距離計算\n                dx = actual_measurement_x - clearance_x\n                dy = height - clearance_y\n                distance_to_point = math.sqrt(dx**2 + dy**2)\n                \n                if distance_to_point < min_distance:\n                    min_distance = distance_to_point\n                    closest_point = (clearance_x, clearance_y)\n            \n            # 最短距離線を緑の点線で表示（支障時は限界支障量、適合時は限界余裕）\n            if closest_point:\n                if result['is_interference']:\n                    label_text = f'限界支障量: {result[\"clearance_margin\"]}mm'\n                else:\n                    label_text = f'限界余裕: {result[\"clearance_margin\"]}mm'\n                \n                self.ax.plot([actual_measurement_x, closest_point[0]], \n                           [height, closest_point[1]], \n                           'g--', linewidth=2, label=label_text)\n                # 最近点をマーク（小さく）\n                self.ax.plot(closest_point[0], closest_point[1], 'go', markersize=4)\n        \n        # V12新機能: OIRAN浮き上がり量の可視化\n        if cant > 0:\n            # 1225mm地点と1900mm地点でのOIRAN浮き上がり量を表示\n            oiran_lift_1225 = self.clearance_model.calculate_oiran_lift_amount(1225, 0, cant)\n            oiran_lift_1900 = self.clearance_model.calculate_oiran_lift_amount(1900, 0, cant)\n            \n            # OIRAN浮き上がり量を示すライン\n            self.ax.plot([-1225, -1225], [0, oiran_lift_1225], 'r:', linewidth=2, \n                        label=f'OIRAN浮上1225mm: {oiran_lift_1225:.1f}mm')\n            self.ax.plot([1900, 1900], [0, oiran_lift_1900], 'r:', linewidth=2, \n                        label=f'OIRAN浮上1900mm: {oiran_lift_1900:.1f}mm')\n            \n            # 浮き上がり量のマーカー\n            self.ax.plot(-1225, oiran_lift_1225, 'ro', markersize=4)\n            self.ax.plot(1900, oiran_lift_1900, 'ro', markersize=4)\n        \n        # グラフ設定（V10・V11と同じ）\n        self.ax.grid(True, alpha=0.3)\n        self.ax.set_xlabel('離れ (mm)', fontsize=12)\n        self.ax.set_ylabel('高さ (mm)', fontsize=12)\n        self.ax.set_title('建築限界シミュレーション v12.0 OIRAN Exact', fontsize=14)\n        \n        # 表示範囲\n        try:\n            distance_value = abs(distance)\n            x_max = max(3000, distance_value + 1000)\n        except:\n            x_max = 3000\n        self.ax.set_xlim(-x_max, x_max)\n        self.ax.set_ylim(-500, 6000)\n        \n        # 凡例\n        self.ax.legend(loc='upper right')\n        \n        # 描画更新\n        self.canvas.draw()\n    \n    def reset_values(self):\n        \"\"\"値リセット（V10・V11と同じ）\"\"\"\n        self.distance_var.set(\"0\")\n        self.height_var.set(\"0\")\n        self.cant_var.set(\"0\")\n        self.radius_var.set(\"0\")\n        self.result_text.delete(1.0, tk.END)\n        self.calculation_result = None\n        self.is_calculated = False\n        self.setup_initial_graph()\n    \n    def run(self):\n        \"\"\"アプリケーション実行\"\"\"\n        self.root.mainloop()\n\n\ndef main():\n    \"\"\"メイン関数\"\"\"\n    app = ClearanceAppV12OIRANExactUI()\n    app.run()\n\n\nif __name__ == \"__main__\":\n    main()