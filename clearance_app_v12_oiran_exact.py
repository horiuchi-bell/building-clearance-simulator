#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
å»ºç¯‰é™ç•Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ v12 OIRAN Exactç‰ˆ
V11 + OIRANã‚¨ã‚¯ã‚»ãƒ«é«˜ã•0åœ°ç‚¹ã®æµ®ãä¸ŠãŒã‚Šå®Œå…¨å†ç¾
é«˜ã•0åŸºæº– + å…ƒãƒ¢ãƒ‡ãƒ«æ¯”ä¾‹æ–¹å¼
"""

import tkinter as tk
from tkinter import ttk, messagebox
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import numpy as np
import platform
import tkinter.font as tkFont
import json
import math
from typing import List, Tuple, Dict, Any

class ClearanceModelV12OIRANExact:
    """å»ºç¯‰é™ç•Œãƒ¢ãƒ‡ãƒ« v12 OIRAN Exact - OIRANã‚¨ã‚¯ã‚»ãƒ«é«˜ã•0åœ°ç‚¹å®Œå…¨å†ç¾"""
    
    def __init__(self):
        """åˆæœŸåŒ–"""
        self.rail_gauge = 1067  # è»Œé–“ (mm)
        # OIRANã‚¨ã‚¯ã‚»ãƒ«è§£æçµæœã®ä¿‚æ•°
        self.oiran_coeff_a = 0.00066533
        self.oiran_coeff_b = -0.264133
        
    def calculate_base_clearance_at_height(self, height: float) -> float:
        """é«˜ã•ã«å¯¾ã™ã‚‹åŸºæœ¬å»ºç¯‰é™ç•Œé›¢ã‚Œï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰"""
        if height < 0:
            return float('inf')
        elif height < 25:
            return 1225
        elif height < 375:
            # 25mmã‹ã‚‰375mmã¾ã§æ–œã‚ã®ç›´ç·š
            return 1225 + (height - 25) * (1575 - 1225) / (375 - 25)
        elif height < 920:
            return 1575
        elif height < 3156:
            return 1900
        elif height < 3823:
            # å††å¼§éƒ¨åˆ†ï¼šä¸­å¿ƒ(0, 2150), åŠå¾„2150
            discriminant = 2150**2 - (height - 2150)**2
            if discriminant < 0:
                return 0
            return math.sqrt(discriminant)
        elif height < 5190:
            return 1350
        else:
            # ä¸Šéƒ¨å††å¼§ï¼šä¸­å¿ƒ(0, 4000), åŠå¾„1800
            discriminant = 1800**2 - (height - 4000)**2
            if discriminant < 0:
                return 0
            return math.sqrt(discriminant)
    
    def calculate_cant_correction(self, height: float, cant_mm: float) -> float:
        """ã‚«ãƒ³ãƒˆè£œæ­£é‡è¨ˆç®—ï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰"""
        if cant_mm == 0:
            return 0
        cant_angle = math.atan(cant_mm / self.rail_gauge)
        return height * math.sin(cant_angle)
    
    def calculate_curve_widening(self, curve_radius_m: float) -> float:
        """æ›²ç·šæ‹¡å¹…é‡è¨ˆç®—ï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰"""
        if curve_radius_m == 0:
            return 0
        return 23000.0 / curve_radius_m
    
    def calculate_required_clearance(self, height: float, cant_mm: float = 0, curve_radius_m: float = 0) -> float:
        """å¿…è¦é›¢ã‚Œè¨ˆç®—ï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰"""
        base_clearance = self.calculate_base_clearance_at_height(height)
        cant_correction = self.calculate_cant_correction(height, cant_mm)
        curve_widening = self.calculate_curve_widening(curve_radius_m)
        required_clearance = base_clearance + cant_correction + curve_widening
        return required_clearance
    
    def calculate_oiran_lift_coefficient(self, x_distance: float) -> float:
        """OIRANã‚¨ã‚¯ã‚»ãƒ«é«˜ã•0åœ°ç‚¹ã®æµ®ãä¸ŠãŒã‚Šä¿‚æ•°è¨ˆç®—ï¼ˆV12æ–°æ©Ÿèƒ½ï¼‰
        
        ä¿‚æ•° = 0.00066533 Ã— Xè·é›¢ + (-0.264133)
        
        X=1225mm: ä¿‚æ•°=0.5509ï¼ˆå®Ÿæ¸¬31.5960mmï¼‰
        X=1900mm: ä¿‚æ•°=1.0000ï¼ˆå®Ÿæ¸¬88.9371mmï¼‰
        """
        coefficient = self.oiran_coeff_a * x_distance + self.oiran_coeff_b
        return coefficient
    
    def calculate_oiran_lift_amount(self, x_distance: float, y_height: float, cant_mm: float) -> float:
        """OIRANã‚¨ã‚¯ã‚»ãƒ«æ–¹å¼ã®æµ®ãä¸ŠãŒã‚Šé‡è¨ˆç®—ï¼ˆV12æ–°æ©Ÿèƒ½ï¼‰
        
        1. é«˜ã•0ï¼ˆãƒ¬ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ï¼‰ã§ã®æµ®ãä¸ŠãŒã‚Šé‡ã‚’åŸºæº–ã¨ã™ã‚‹
        2. ä»–ã®é«˜ã•ã§ã¯å…ƒã®ãƒ¢ãƒ‡ãƒ«å¯¸æ³•ã«æ¯”ä¾‹ã—ã¦èª¿æ•´
        """
        if cant_mm == 0:
            return 0
        
        cant_angle = math.atan(cant_mm / self.rail_gauge)
        
        # é«˜ã•0ã§ã®åŸºæº–æµ®ãä¸ŠãŒã‚Šé‡
        oiran_coefficient = self.calculate_oiran_lift_coefficient(x_distance)
        base_lift = x_distance * math.sin(cant_angle) * oiran_coefficient
        
        # é«˜ã•ã«ã‚ˆã‚‹èª¿æ•´ï¼ˆå…ƒã®ãƒ¢ãƒ‡ãƒ«æ¯”ä¾‹ï¼‰
        if y_height == 0:
            return base_lift
        else:
            # é«˜ã•ã«ã‚ˆã‚‹æ¯”ä¾‹èª¿æ•´ï¼ˆV11ã¨åŒæ§˜ã®è€ƒãˆæ–¹ã ãŒã€OIRANåŸºæº–ã‚’ä½¿ç”¨ï¼‰
            # é«˜ã•ãŒä¸ŠãŒã‚‹ã»ã©ã€æ°´å¹³è·é›¢ã®å½±éŸ¿ãŒå°‘ãªããªã‚‹ã¨ä»®å®š
            height_factor = 1.0 + (y_height / 5000.0) * 0.2  # é«˜ã•5000mmã§20%å¢—åŠ 
            return base_lift * height_factor
    
    def create_accurate_clearance(self) -> List[Tuple[float, float]]:
        """å»ºç¯‰é™ç•Œã®å½¢çŠ¶ã‚’ä½œæˆï¼ˆV10ãƒ»V11ã¨åŒä¸€ãƒ»é«˜ç²¾åº¦ç‰ˆï¼‰"""
        points = []
        
        # å³å´ã®è¼ªéƒ­ã‚’å®šç¾©
        # ä¸‹éƒ¨
        points.append((1225, 0))      # ãƒ¬ãƒ¼ãƒ«ãƒ¬ãƒ™ãƒ«ã‹ã‚‰é–‹å§‹
        points.append((1225, 25))     # 25mmã¾ã§
        
        # 25mmâ†’375mmã®æ–œã‚ç›´ç·šï¼ˆç´°ã‹ãåˆ†å‰²ï¼‰
        for h in np.linspace(25, 375, 10):
            x = 1225 + (h - 25) * (1575 - 1225) / (375 - 25)
            points.append((x, h))
        
        points.append((1575, 920))    # 920mmã¾ã§
        points.append((1900, 920))    # 920mmã‹ã‚‰æœ€å¤§å¹…
        points.append((1900, 3156))   # 3156mmã¾ã§
        
        # å††å¼§éƒ¨åˆ† (3156mmâ†’3823mm) - è¶…é«˜ç²¾åº¦
        for h in np.linspace(3156, 3823, 100):
            discriminant = 2150**2 - (h - 2150)**2
            if discriminant >= 0:
                x = math.sqrt(discriminant)
                points.append((x, h))
        
        # 3823mmä»¥é™
        points.append((1350, 3823))
        points.append((1350, 4300))
        
        # ä¸Šéƒ¨å††å¼§ï¼ˆã‚ˆã‚Šç´°ã‹ãï¼‰
        center_x, center_y, radius = 0, 4000, 1800
        x_boundary = 1350
        
        discriminant = radius**2 - x_boundary**2
        if discriminant >= 0:
            y_intersect = center_y + math.sqrt(discriminant)
            start_angle = math.atan2(y_intersect - center_y, x_boundary - center_x)
            end_angle = math.pi / 2
            
            for i in range(30):
                angle = start_angle + (end_angle - start_angle) * i / 29
                x = center_x + radius * math.cos(angle)
                y = center_y + radius * math.sin(angle)
                
                if abs(x) <= 1350 and y <= 5700 and y >= 4000:
                    points.append((x, y))
        
        # æœ€ä¸Šéƒ¨
        points.append((1350, 5700))
        points.append((-1350, 5700))
        
        # å·¦å´ï¼ˆå¯¾ç§°ï¼‰
        right_points = [(x, y) for x, y in points if x > 0]
        right_points.reverse()
        
        for x, y in right_points[1:-1]:
            points.append((-x, y))
        
        # å½¢çŠ¶ã‚’é–‰ã˜ã‚‹
        points.append((1225, 0))
        
        return points
    
    def transform_clearance(self, points: List[Tuple[float, float]],
                           cant_mm: float, curve_radius_m: float) -> List[Tuple[float, float]]:
        """å»ºç¯‰é™ç•Œå¤‰å½¢ï¼ˆV12: å›è»¢å¤‰å½¢ + OIRANæµ®ãä¸ŠãŒã‚Šï¼‰"""\n        if not points:\n            return []\n        \n        coords = np.array(points)\n        \n        # ã‚«ãƒ³ãƒˆå¤‰å½¢ï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰\n        if cant_mm != 0:\n            angle_rad = np.arctan(cant_mm / self.rail_gauge)\n            cos_a, sin_a = np.cos(angle_rad), np.sin(angle_rad)\n            rotation_matrix = np.array([[cos_a, -sin_a], [sin_a, cos_a]])\n            coords = coords @ rotation_matrix.T\n        \n        # V12æ–°æ©Ÿèƒ½: OIRANæ–¹å¼ã®æµ®ãä¸ŠãŒã‚Šé©ç”¨\n        if cant_mm != 0:\n            # å„ç‚¹ã§ã®OIRANæµ®ãä¸ŠãŒã‚Šé‡ã‚’è¨ˆç®—ã—ã¦é©ç”¨\n            for i in range(len(coords)):\n                x_abs = abs(coords[i, 0])  # Xåº§æ¨™ã®çµ¶å¯¾å€¤\n                y_coord = coords[i, 1]     # Yåº§æ¨™\n                \n                # OIRANæµ®ãä¸ŠãŒã‚Šé‡ã‚’è¨ˆç®—\n                oiran_lift = self.calculate_oiran_lift_amount(x_abs, y_coord, cant_mm)\n                \n                # Yåº§æ¨™ã«æµ®ãä¸ŠãŒã‚Šé‡ã‚’åŠ ç®—\n                coords[i, 1] = coords[i, 1] + oiran_lift\n        \n        # æ›²ç·šæ‹¡å¹…ï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰\n        if curve_radius_m > 0:\n            widening_factor = 23000.0 / curve_radius_m\n            coords[:, 0] = coords[:, 0] + np.sign(coords[:, 0]) * widening_factor\n        \n        return coords.tolist()\n    \n    def generate_building_clearance_data(self, cant_mm: float, curve_radius_m: float) -> List[Tuple[float, float]]:\n        \"\"\"å»ºç¯‰é™ç•Œãƒ‡ãƒ¼ã‚¿ç”Ÿæˆï¼ˆV10ãƒ»V11ã¨åŒä¸€ãƒ»1775å€‹ã®ç‚¹ï¼‰\"\"\"\n        clearance_data = []\n        heights = np.linspace(0, 5700, 1775)\n        \n        for height in heights:\n            total_clearance = self.calculate_required_clearance(height, cant_mm, curve_radius_m)\n            clearance_data.append((total_clearance, height))\n        \n        return clearance_data\n\n# V11ã®ExcelAccurateCalculatorV11WithLiftã‚’ãã®ã¾ã¾ä½¿ç”¨\nclass ExcelAccurateCalculatorV12OIRANExact:\n    \"\"\"Excelè¨ˆç®—æ–¹å¼ã®å®Œå…¨å†ç¾è¨ˆç®—å™¨ V12 OIRAN Exactï¼ˆV11ã¨åŒä¸€æ©Ÿèƒ½ï¼‰\"\"\"\n    \n    def __init__(self):\n        \"\"\"åˆæœŸåŒ–\"\"\"\n        self.rail_gauge = 1067  # è»Œé–“ (mm)\n        # å»ºç¯‰é™ç•Œãƒ‡ãƒ¼ã‚¿ï¼ˆV10ã§è§£ææ¸ˆã¿ï¼‰\n        self.original_clearance_data = self._create_original_clearance_data()\n    \n    def _create_original_clearance_data(self) -> List[Tuple[float, float]]:\n        \"\"\"å…ƒå»ºç¯‰é™ç•Œãƒ‡ãƒ¼ã‚¿ä½œæˆï¼ˆ1775å€‹ã®ç‚¹ï¼‰\"\"\"\n        clearance_data = []\n        heights = np.linspace(0, 5700, 1775)\n        \n        for height in heights:\n            if height < 0:\n                clearance = float('inf')\n            elif height < 25:\n                clearance = 1225\n            elif height < 375:\n                clearance = 1225 + (height - 25) * (1575 - 1225) / (375 - 25)\n            elif height < 920:\n                clearance = 1575\n            elif height < 3156:\n                clearance = 1900\n            elif height < 3823:\n                discriminant = 2150**2 - (height - 2150)**2\n                if discriminant < 0:\n                    clearance = 0\n                else:\n                    clearance = math.sqrt(discriminant)\n            elif height < 5190:\n                clearance = 1350\n            else:\n                discriminant = 1800**2 - (height - 4000)**2\n                if discriminant < 0:\n                    clearance = 0\n                else:\n                    clearance = math.sqrt(discriminant)\n            \n            clearance_data.append((clearance, height))\n        \n        return clearance_data\n    \n    def coordinate_transform_to_rail_center(self, measurement_distance: float, measurement_height: float, \n                                          cant_mm: float) -> Tuple[float, float]:\n        \"\"\"æ¸¬å®šç‚¹åº§æ¨™ã‚’ãƒ¬ãƒ¼ãƒ«ã‚»ãƒ³ã‚¿ãƒ¼åŸºæº–ã«å¤‰æ›ï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰\"\"\"\n        if cant_mm == 0:\n            return measurement_distance, measurement_height\n        \n        # ã‚«ãƒ³ãƒˆè§’åº¦\n        cant_angle = math.atan(cant_mm / self.rail_gauge)\n        \n        # Excelé€†è§£æçµæœã«åŸºã¥ãæ­£ç¢ºãªåº§æ¨™å¤‰æ›\n        # A8: æ¸¬å®šé›¢ã‚Œã‹ã‚‰æ¸¬å®šé«˜ã•ã®ã‚«ãƒ³ãƒˆè§’åº¦ã«ã‚ˆã‚‹æ°´å¹³æˆåˆ†ã‚’å¼•ã\n        x_coord = measurement_distance - measurement_height * math.sin(cant_angle)\n        \n        # B8: æ¸¬å®šé«˜ã•ã®ã‚«ãƒ³ãƒˆè§’åº¦ã«ã‚ˆã‚‹ã‚³ã‚µã‚¤ãƒ³å¤‰æ›\n        y_coord = measurement_height * math.cos(cant_angle)\n        \n        return x_coord, y_coord\n    \n    def calculate_required_clearance_excel_method(self, measurement_distance: float, measurement_height: float,\n                                                 cant_mm: float, curve_radius_m: float) -> float:\n        \"\"\"Excel D18ã‚»ãƒ«ã®å¿…è¦é›¢ã‚Œè¨ˆç®—å®Œå…¨å†ç¾ï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰\"\"\"\n        # åº§æ¨™å¤‰æ›\n        x_coord, y_coord = self.coordinate_transform_to_rail_center(measurement_distance, measurement_height, cant_mm)\n        \n        # åŸºæœ¬å»ºç¯‰é™ç•Œè¨ˆç®—ï¼ˆå¤‰æ›å¾Œåº§æ¨™ã‚’ä½¿ç”¨ï¼‰\n        if y_coord >= 2150:\n            discriminant = 2150**2 - (y_coord - 2150)**2\n            if discriminant < 0:\n                base_clearance = 0\n            else:\n                base_clearance = math.sqrt(discriminant)\n        else:\n            base_clearance = 2150\n        \n        # æ‹¡å¹…é‡è¨ˆç®—\n        if curve_radius_m > 0:\n            widening = 23000.0 / curve_radius_m\n        else:\n            widening = 0\n        \n        # ã‚«ãƒ³ãƒˆè£œæ­£ï¼ˆå…ƒã®æ¸¬å®šåº§æ¨™ã‚’ä½¿ç”¨ï¼‰\n        if cant_mm == 0:\n            cant_correction = 0\n        else:\n            cant_angle = math.atan(cant_mm / self.rail_gauge)\n            cant_correction = measurement_height * math.sin(cant_angle)\n        \n        # æœ€çµ‚çš„ãªå¿…è¦é›¢ã‚Œ\n        required_clearance = base_clearance + widening + cant_correction\n        \n        return required_clearance\n    \n    def calculate_ag2_excel_method(self, measurement_distance: float, measurement_height: float,\n                                  cant_mm: float, curve_radius_m: float) -> float:\n        \"\"\"Excel AG2ã‚»ãƒ«ã®è¨ˆç®—å®Œå…¨å†ç¾ï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰\"\"\"\n        # ãƒ¬ãƒ¼ãƒ«ã‚»ãƒ³ã‚¿ãƒ¼åŸºæº–ã®åº§æ¨™å¤‰æ›\n        rail_x, rail_y = self.coordinate_transform_to_rail_center(measurement_distance, measurement_height, cant_mm)\n        \n        # å…ƒå»ºç¯‰é™ç•Œãƒ‡ãƒ¼ã‚¿ã¨ã®æœ€çŸ­è·é›¢è¨ˆç®—\n        min_distance = float('inf')\n        \n        for clearance_x, clearance_y in self.original_clearance_data:\n            # æ°´å¹³è·é›¢å·®\n            dx = rail_x - clearance_x\n            # å‚ç›´è·é›¢å·®\n            dy = rail_y - clearance_y\n            # ãƒ¦ãƒ¼ã‚¯ãƒªãƒƒãƒ‰è·é›¢\n            distance = math.sqrt(dx**2 + dy**2)\n            \n            if distance < min_distance:\n                min_distance = distance\n        \n        return min_distance\n    \n    def calculate_clearance_margin_excel_method(self, measurement_distance: float, measurement_height: float,\n                                              cant_mm: float, curve_radius_m: float) -> Dict[str, Any]:\n        \"\"\"Excel B24ã‚»ãƒ«ã®é™ç•Œä½™è£•è¨ˆç®—å®Œå…¨å†ç¾ï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰\"\"\"\n        ag2 = self.calculate_ag2_excel_method(measurement_distance, measurement_height, cant_mm, curve_radius_m)\n        \n        # ãƒ¬ãƒ¼ãƒ«ã‚»ãƒ³ã‚¿ãƒ¼åŸºæº–ã®åº§æ¨™å¤‰æ›ï¼ˆæˆ»ã‚Šå€¤ç”¨ï¼‰\n        rail_x, rail_y = self.coordinate_transform_to_rail_center(measurement_distance, measurement_height, cant_mm)\n        \n        # Excel B24ã®è¨ˆç®—å¼å†ç¾\n        if ag2 < 5:\n            corrected_margin = 0\n            correction_method = \"AG2 < 5: çµæœ = 0\"\n        elif ag2 < 13:\n            corrected_margin = math.sqrt(ag2**2 - 25)\n            correction_method = f\"5 â‰¤ AG2 < 13: çµæœ = âˆš({ag2:.1f}Â² - 25) = {corrected_margin:.1f}\"\n        else:\n            corrected_margin = ag2\n            correction_method = f\"AG2 â‰¥ 13: çµæœ = AG2 = {ag2:.1f}\"\n        \n        # å»ºç¯‰é™ç•Œå†…å¤–åˆ¤å®š\n        is_inside_clearance = self._is_point_inside_building_clearance(rail_x, rail_y)\n        \n        # æ”¹è‰¯ã•ã‚ŒãŸæ”¯éšœåˆ¤å®šï¼šå»ºç¯‰é™ç•Œå†…å´ã«ã‚ã‚‹å ´åˆã¯å¿…ãšæ”¯éšœ\n        is_interference = is_inside_clearance or ag2 < 5 or corrected_margin <= 0\n        \n        # æ”¯éšœæ™‚ã¯ROUNDUPã€éæ”¯éšœæ™‚ã¯ROUNDDOWN\n        if is_interference:\n            final_margin = math.ceil(corrected_margin)\n        else:\n            final_margin = math.floor(corrected_margin)\n        \n        return {\n            'ag2': ag2,  # AG2è¨ˆç®—ã¯å…ƒã®Excelæ–¹å¼ã‚’ç¶­æŒ\n            'corrected_margin': corrected_margin,\n            'final_margin': final_margin,  # å»ºç¯‰é™ç•Œå†…å´ã§ã‚‚æ­£ã—ã„æ”¯éšœé‡ã‚’è¡¨ç¤º\n            'correction_method': correction_method + (\" (å»ºç¯‰é™ç•Œå†…å´)\" if is_inside_clearance else \"\"),\n            'is_interference': is_interference,\n            'rail_center_coords': (rail_x, rail_y),\n            'is_inside_clearance': is_inside_clearance\n        }\n    \n    def _is_point_inside_building_clearance(self, x: float, y: float) -> bool:\n        \"\"\"ç‚¹ãŒå»ºç¯‰é™ç•Œå†…å´ã«ã‚ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰\"\"\"\n        # é«˜ã•ç¯„å›²ãƒã‚§ãƒƒã‚¯\n        if y < 0 or y > 5700:\n            return False\n        \n        # å„é«˜ã•ã§ã®å»ºç¯‰é™ç•Œå€¤ã‚’å–å¾—\n        if y < 25:\n            clearance_limit = 1225\n        elif y < 375:\n            clearance_limit = 1225 + (y - 25) * (1575 - 1225) / (375 - 25)\n        elif y < 920:\n            clearance_limit = 1575\n        elif y < 3156:\n            clearance_limit = 1900\n        elif y < 3823:\n            discriminant = 2150**2 - (y - 2150)**2\n            if discriminant < 0:\n                clearance_limit = 0\n            else:\n                clearance_limit = math.sqrt(discriminant)\n        elif y < 5190:\n            clearance_limit = 1350\n        else:\n            discriminant = 1800**2 - (y - 4000)**2\n            if discriminant < 0:\n                clearance_limit = 0\n            else:\n                clearance_limit = math.sqrt(discriminant)\n        \n        # Xåº§æ¨™ã®çµ¶å¯¾å€¤ãŒå»ºç¯‰é™ç•Œå€¤ã‚ˆã‚Šå°ã•ã„å ´åˆã¯å†…å´\n        return abs(x) < clearance_limit\n    \n    def calculate_all_excel_method(self, measurement_distance: float, measurement_height: float,\n                                  cant_mm: float = 0, curve_radius_m: float = 0) -> Dict[str, Any]:\n        \"\"\"Excelå®Œå…¨å†ç¾çµ±åˆè¨ˆç®—ï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰\"\"\"\n        required_clearance = self.calculate_required_clearance_excel_method(\n            measurement_distance, measurement_height, cant_mm, curve_radius_m)\n        \n        margin_result = self.calculate_clearance_margin_excel_method(\n            measurement_distance, measurement_height, cant_mm, curve_radius_m)\n        \n        return {\n            'measurement_distance': measurement_distance,\n            'measurement_height': measurement_height,\n            'cant_mm': cant_mm,\n            'curve_radius_m': curve_radius_m,\n            'required_clearance': required_clearance,\n            'clearance_margin': margin_result['final_margin'],\n            'ag2_distance': margin_result['ag2'],\n            'is_interference': margin_result['is_interference'],\n            'correction_method': margin_result['correction_method'],\n            'details': margin_result\n        }\n    \n    def _calculate_display_coordinates(self, measurement_distance: float, measurement_height: float, \n                                     cant_mm: float) -> Tuple[float, float]:\n        \"\"\"è¡¨ç¤ºåº§æ¨™è¨ˆç®—ï¼ˆV10ãƒ»V11ã¨åŒä¸€ãƒ»ã‚«ãƒ³ãƒˆå¤‰å½¢è€ƒæ…®ã€åº§æ¨™ç³»ä¸€è‡´ç‰ˆï¼‰\"\"\"\n        if cant_mm == 0:\n            # ã‚«ãƒ³ãƒˆ0ã®å ´åˆã¯å¾“æ¥é€šã‚Š\n            display_x = -abs(measurement_distance) if measurement_distance > 0 else abs(measurement_distance)\n            return display_x, measurement_height\n        \n        # ãƒ¬ãƒ¼ãƒ«ã‚»ãƒ³ã‚¿ãƒ¼åº§æ¨™ã‚’å–å¾—\n        rail_x, rail_y = self.coordinate_transform_to_rail_center(measurement_distance, measurement_height, cant_mm)\n        \n        # ãƒ¬ãƒ¼ãƒ«ã‚»ãƒ³ã‚¿ãƒ¼åº§æ¨™ã‚’ã‚«ãƒ³ãƒˆå¤‰å½¢ã—ã¦è¡¨ç¤ºåº§æ¨™ã«å¤‰æ›\n        cant_angle = math.atan(cant_mm / self.rail_gauge)\n        cos_a, sin_a = math.cos(cant_angle), math.sin(cant_angle)\n        \n        # ã‚«ãƒ³ãƒˆå¤‰å½¢ï¼ˆå»ºç¯‰é™ç•Œãƒ¢ãƒ‡ãƒ«ã¨åŒã˜å¤‰å½¢ï¼‰\n        display_x = rail_x * cos_a - rail_y * sin_a\n        display_y = rail_x * sin_a + rail_y * cos_a\n        \n        # V9å½¢å¼ã®è¡¨ç¤ºï¼ˆå·¦å´è¡¨ç¤ºï¼‰\n        if measurement_distance > 0:\n            display_x = -abs(display_x)\n        \n        return display_x, display_y\n\n# V11ã®NumericKeypadã¨ClearanceAppã‚’V12ç”¨ã«ç¶™æ‰¿\nclass NumericKeypad(tk.Toplevel):\n    \"\"\"ãƒ†ãƒ³ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰ï¼ˆV10ãƒ»V11ã¨åŒä¸€ï¼‰\"\"\"\n    \n    def __init__(self, parent, entry_widget, allow_negative=False):\n        super().__init__(parent)\n        self.entry_widget = entry_widget\n        self.allow_negative = allow_negative\n        self.result = None\n        \n        self.title(\"æ•°å€¤å…¥åŠ›\")\n        self.geometry(\"300x400\")\n        self.transient(parent)\n        self.grab_set()\n        \n        # ä¸­å¤®é…ç½®\n        self.geometry(\"+%d+%d\" % (parent.winfo_rootx() + 50, parent.winfo_rooty() + 50))\n        \n        self.create_widgets()\n        \n        # ESCã‚­ãƒ¼ã§é–‰ã˜ã‚‹\n        self.bind('<Escape>', lambda e: self.destroy())\n        \n        # ç¾åœ¨ã®å€¤ã‚’è¡¨ç¤º\n        current_value = self.entry_widget.get()\n        if current_value and current_value != \"0\":\n            self.display_var.set(current_value)\n    \n    def create_widgets(self):\n        \"\"\"ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆä½œæˆ\"\"\"\n        # è¡¨ç¤ºã‚¨ãƒªã‚¢\n        display_frame = ttk.Frame(self)\n        display_frame.pack(fill=tk.X, padx=10, pady=10)\n        \n        self.display_var = tk.StringVar(value=\"0\")\n        display_label = ttk.Label(display_frame, textvariable=self.display_var, \n                                 font=(\"Arial\", 16), background=\"white\", \n                                 relief=\"sunken\", anchor=\"e\")\n        display_label.pack(fill=tk.X, ipady=10)\n        \n        # ãƒœã‚¿ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ \n        button_frame = ttk.Frame(self)\n        button_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # ãƒœã‚¿ãƒ³é…ç½®\n        buttons = [\n            ('C', 0, 0), ('Â±', 0, 1) if self.allow_negative else ('', 0, 1), ('âŒ«', 0, 2),\n            ('7', 1, 0), ('8', 1, 1), ('9', 1, 2),\n            ('4', 2, 0), ('5', 2, 1), ('6', 2, 2),\n            ('1', 3, 0), ('2', 3, 1), ('3', 3, 2),\n            ('0', 4, 0), ('.', 4, 1), ('ç¢ºå®š', 4, 2)\n        ]\n        \n        for (text, row, col) in buttons:\n            if text:\n                btn = ttk.Button(button_frame, text=text, \n                               command=lambda t=text: self.button_click(t))\n                btn.grid(row=row, column=col, sticky=\"nsew\", padx=2, pady=2)\n        \n        # ã‚°ãƒªãƒƒãƒ‰è¨­å®š\n        for i in range(5):\n            button_frame.grid_rowconfigure(i, weight=1)\n        for i in range(3):\n            button_frame.grid_columnconfigure(i, weight=1)\n    \n    def button_click(self, text):\n        \"\"\"ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯å‡¦ç†\"\"\"\n        current = self.display_var.get()\n        \n        if text == 'C':\n            self.display_var.set(\"0\")\n        elif text == 'âŒ«':\n            if len(current) > 1:\n                self.display_var.set(current[:-1])\n            else:\n                self.display_var.set(\"0\")\n        elif text == 'Â±' and self.allow_negative:\n            if current != \"0\":\n                if current.startswith('-'):\n                    self.display_var.set(current[1:])\n                else:\n                    self.display_var.set('-' + current)\n        elif text == '.':\n            if '.' not in current:\n                self.display_var.set(current + '.')\n        elif text == 'ç¢ºå®š':\n            try:\n                value = float(self.display_var.get())\n                self.entry_widget.delete(0, tk.END)\n                self.entry_widget.insert(0, str(value))\n                self.destroy()\n            except ValueError:\n                messagebox.showerror(\"ã‚¨ãƒ©ãƒ¼\", \"ç„¡åŠ¹ãªæ•°å€¤ã§ã™\")\n        elif text.isdigit():\n            if current == \"0\":\n                self.display_var.set(text)\n            else:\n                self.display_var.set(current + text)\n\nclass ClearanceAppV12OIRANExactUI:\n    \"\"\"å»ºç¯‰é™ç•Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ V12 OIRAN Exact UIç‰ˆ\"\"\"\n    \n    def __init__(self):\n        \"\"\"åˆæœŸåŒ–\"\"\"\n        self.root = tk.Tk()\n        self.root.title(\"å»ºç¯‰é™ç•Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ V12.0 OIRAN Exact - OIRANã‚¨ã‚¯ã‚»ãƒ«é«˜ã•0åœ°ç‚¹å®Œå…¨å†ç¾\")\n        \n        # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã¨ä¸­å¤®é…ç½®\n        window_width = 1100\n        window_height = 700\n        screen_width = self.root.winfo_screenwidth()\n        screen_height = self.root.winfo_screenheight()\n        x = (screen_width - window_width) // 2\n        y = (screen_height - window_height) // 2\n        \n        self.root.geometry(f\"{window_width}x{window_height}+{x}+{y}\")\n        self.root.minsize(1100, 700)\n        \n        # è¨ˆç®—ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆV12ã®OIRAN Exactæ–¹å¼ï¼‰\n        self.excel_calculator = ExcelAccurateCalculatorV12OIRANExact()\n        \n        # å»ºç¯‰é™ç•Œãƒ¢ãƒ‡ãƒ«ï¼ˆV12ã®OIRANã‚¨ã‚¯ã‚»ãƒ«å¯¾å¿œï¼‰\n        self.clearance_model = ClearanceModelV12OIRANExact()\n        self.base_clearance = self.clearance_model.create_accurate_clearance()\n        \n        # è¨ˆç®—çµæœä¿å­˜ç”¨\n        self.calculation_result = None\n        self.is_calculated = False\n        \n        # æ—¥æœ¬èªãƒ•ã‚©ãƒ³ãƒˆè¨­å®š\n        self.setup_japanese_font()\n        \n        # UIæ§‹ç¯‰\n        self.create_widgets()\n        \n        # åˆæœŸè¡¨ç¤ºæ›´æ–°\n        self.setup_initial_graph()\n        \n    def setup_japanese_font(self):\n        \"\"\"æ—¥æœ¬èªãƒ•ã‚©ãƒ³ãƒˆè¨­å®šï¼ˆV10ãƒ»V11ã¨åŒã˜ï¼‰\"\"\"\n        system = platform.system()\n        if system == \"Windows\":\n            self.default_font = (\"Meiryo UI\", 10)\n            self.label_font = (\"Meiryo UI\", 11, \"bold\")\n            self.title_font = (\"Meiryo UI\", 14, \"bold\")\n        elif system == \"Darwin\":  # macOS\n            self.default_font = (\"Hiragino Sans\", 12)\n            self.label_font = (\"Hiragino Sans\", 13, \"bold\")\n            self.title_font = (\"Hiragino Sans\", 16, \"bold\")\n        else:  # Linux/ãã®ä»–\n            self.default_font = (\"Noto Sans CJK JP\", 10)\n            self.label_font = (\"Noto Sans CJK JP\", 11, \"bold\")\n            self.title_font = (\"Noto Sans CJK JP\", 14, \"bold\")\n        \n        self.root.option_add(\"*Font\", self.default_font)\n    \n    def create_widgets(self):\n        \"\"\"ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆä½œæˆï¼ˆV10ãƒ»V11ã®UIãƒ‡ã‚¶ã‚¤ãƒ³ã‚’å®Œå…¨æ¡ç”¨ï¼‰\"\"\"\n        # ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒŠ\n        main_container = ttk.Frame(self.root)\n        main_container.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n        \n        # å·¦å´ï¼šå…¥åŠ›ãƒ‘ãƒãƒ«\n        self.create_input_panel(main_container)\n        \n        # å³å´ï¼šè¡¨ç¤ºã‚¨ãƒªã‚¢\n        self.create_display_area(main_container)\n    \n    def create_input_panel(self, parent):\n        \"\"\"å…¥åŠ›ãƒ‘ãƒãƒ«ä½œæˆï¼ˆV10ãƒ»V11ã®UIã‚’å®Œå…¨æ¡ç”¨ï¼‰\"\"\"\n        input_frame = ttk.LabelFrame(parent, text=\"æ¸¬å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å…¥åŠ›\", padding=\"20\")\n        input_frame.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 10))\n        \n        # æ¸¬å®šé›¢ã‚Œï¼ˆæœ€åˆã«é…ç½®ï¼‰\n        ttk.Label(input_frame, text=\"æ¸¬å®šé›¢ã‚Œ (mm):\", font=self.label_font).grid(row=0, column=0, sticky=tk.W, pady=10)\n        self.distance_var = tk.StringVar(value=\"0\")\n        self.distance_entry = ttk.Entry(input_frame, textvariable=self.distance_var, width=15, font=self.default_font)\n        self.distance_entry.grid(row=0, column=1, pady=10)\n        \n        distance_keypad_btn = ttk.Button(input_frame, text=\"ğŸ“±\", width=3,\n                                        command=lambda: self.open_keypad(self.distance_entry, True))\n        distance_keypad_btn.grid(row=0, column=2, padx=5)\n        \n        ttk.Label(input_frame, text=\"(æ­£: å·¦å´, è² : å³å´)\", font=(\"\", 9)).grid(row=1, column=0, columnspan=3, pady=(0, 10))\n        \n        # æ¸¬å®šé«˜ã•\n        ttk.Label(input_frame, text=\"æ¸¬å®šé«˜ã• (mm):\", font=self.label_font).grid(row=2, column=0, sticky=tk.W, pady=10)\n        self.height_var = tk.StringVar(value=\"0\")\n        self.height_entry = ttk.Entry(input_frame, textvariable=self.height_var, width=15, font=self.default_font)\n        self.height_entry.grid(row=2, column=1, pady=10)\n        \n        height_keypad_btn = ttk.Button(input_frame, text=\"ğŸ“±\", width=3, \n                                      command=lambda: self.open_keypad(self.height_entry, False))\n        height_keypad_btn.grid(row=2, column=2, padx=5)\n        \n        # ã‚«ãƒ³ãƒˆ\n        ttk.Label(input_frame, text=\"ã‚«ãƒ³ãƒˆ (mm):\", font=self.label_font).grid(row=3, column=0, sticky=tk.W, pady=10)\n        self.cant_var = tk.StringVar(value=\"0\")\n        self.cant_entry = ttk.Entry(input_frame, textvariable=self.cant_var, width=15, font=self.default_font)\n        self.cant_entry.grid(row=3, column=1, pady=10)\n        \n        cant_keypad_btn = ttk.Button(input_frame, text=\"ğŸ“±\", width=3,\n                                     command=lambda: self.open_keypad(self.cant_entry, False))\n        cant_keypad_btn.grid(row=3, column=2, padx=5)\n        \n        # æ›²ç·šåŠå¾„\n        ttk.Label(input_frame, text=\"æ›²ç·šåŠå¾„ (m):\", font=self.label_font).grid(row=4, column=0, sticky=tk.W, pady=10)\n        self.radius_var = tk.StringVar(value=\"0\")\n        self.radius_entry = ttk.Entry(input_frame, textvariable=self.radius_var, width=15, font=self.default_font)\n        self.radius_entry.grid(row=4, column=1, pady=10)\n        \n        radius_keypad_btn = ttk.Button(input_frame, text=\"ğŸ“±\", width=3,\n                                      command=lambda: self.open_keypad(self.radius_entry, False))\n        radius_keypad_btn.grid(row=4, column=2, padx=5)\n        \n        ttk.Label(input_frame, text=\"(0 = ç›´ç·š)\", font=(\"\", 9)).grid(row=5, column=0, columnspan=3, pady=(0, 10))\n        \n        # ãƒœã‚¿ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ \n        button_frame = ttk.Frame(input_frame)\n        button_frame.grid(row=6, column=0, columnspan=3, pady=20)\n        \n        # æ¸¬å®šé–‹å§‹ãƒœã‚¿ãƒ³\n        self.calc_button = ttk.Button(button_frame, text=\"æ¸¬å®šé–‹å§‹\", command=self.calculate,\n                                     style=\"Primary.TButton\")\n        self.calc_button.pack(side=tk.LEFT, padx=5)\n        \n        # ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³\n        self.reset_button = ttk.Button(button_frame, text=\"ãƒªã‚»ãƒƒãƒˆ\", command=self.reset_values)\n        self.reset_button.pack(side=tk.LEFT, padx=5)\n        \n        # çµæœè¡¨ç¤ºã‚¨ãƒªã‚¢\n        result_frame = ttk.LabelFrame(input_frame, text=\"åˆ¤å®šçµæœ\", padding=\"10\")\n        result_frame.grid(row=7, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=20)\n        \n        self.result_text = tk.Text(result_frame, height=12, width=40, font=self.default_font)\n        self.result_text.pack(fill=tk.BOTH, expand=True)\n        \n        # ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š\n        style = ttk.Style()\n        style.configure(\"Primary.TButton\", font=self.label_font)\n    \n    def create_display_area(self, parent):\n        \"\"\"è¡¨ç¤ºã‚¨ãƒªã‚¢ä½œæˆï¼ˆV10ãƒ»V11ã®UIã‚’å®Œå…¨æ¡ç”¨ï¼‰\"\"\"\n        display_frame = ttk.Frame(parent)\n        display_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)\n        \n        # ã‚¿ã‚¤ãƒˆãƒ«\n        title_label = ttk.Label(display_frame, text=\"å»ºç¯‰é™ç•Œãƒ¢ãƒ‡ãƒ«ï¼ˆV12 OIRAN Exactï¼‰\", font=self.title_font)\n        title_label.pack(pady=(0, 10))\n        \n        # Matplotlibãƒ•ã‚£ã‚®ãƒ¥ã‚¢\n        self.figure = Figure(figsize=(8, 6), dpi=100)\n        self.ax = self.figure.add_subplot(111)\n        \n        # ã‚­ãƒ£ãƒ³ãƒã‚¹\n        self.canvas = FigureCanvasTkAgg(self.figure, display_frame)\n        self.canvas.draw()\n        self.canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)\n    \n    def setup_initial_graph(self):\n        \"\"\"åˆæœŸã‚°ãƒ©ãƒ•è¨­å®šï¼ˆV10ãƒ»V11ã¨åŒã˜ï¼‰\"\"\"\n        self.ax.clear()\n        \n        # åŸºæœ¬å»ºç¯‰é™ç•Œè¡¨ç¤º\n        clearance_coords = np.array(self.base_clearance)\n        x_coords = clearance_coords[:, 0]\n        y_coords = clearance_coords[:, 1]\n        \n        self.ax.fill(x_coords, y_coords, color='lightblue', alpha=0.3, label='å»ºç¯‰é™ç•Œ')\n        self.ax.plot(x_coords, y_coords, 'b-', linewidth=2)\n        \n        # ãƒ¬ãƒ¼ãƒ«è¡¨ç¤º\n        rail_width = 100\n        self.ax.fill_between([-rail_width/2, rail_width/2], [0, 0], [50, 50], \n                           color='brown', alpha=0.7, label='ãƒ¬ãƒ¼ãƒ«')\n        \n        # ã‚°ãƒªãƒƒãƒ‰ã¨è»¸è¨­å®š\n        self.ax.grid(True, alpha=0.3)\n        self.ax.set_xlabel('è·é›¢ (mm)', fontsize=12)\n        self.ax.set_ylabel('é«˜ã• (mm)', fontsize=12)\n        self.ax.set_title('å»ºç¯‰é™ç•Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ v12.0 OIRAN Exact', fontsize=14)\n        self.ax.set_xlim(-3000, 3000)\n        self.ax.set_ylim(-500, 6000)\n        self.ax.legend(loc='upper right')\n        \n        self.canvas.draw()\n    \n    def open_keypad(self, entry_widget, allow_negative):\n        \"\"\"ãƒ†ãƒ³ã‚­ãƒ¼ãƒ‘ãƒƒãƒ‰é–‹ãï¼ˆV10ãƒ»V11ã¨åŒã˜ï¼‰\"\"\"\n        NumericKeypad(self.root, entry_widget, allow_negative)\n    \n    def calculate(self):\n        \"\"\"è¨ˆç®—å®Ÿè¡Œï¼ˆV12ã®OIRAN Exactæ–¹å¼ã‚’ä½¿ç”¨ï¼‰\"\"\"\n        try:\n            # å…¥åŠ›å€¤å–å¾—\n            height = float(self.height_var.get())\n            distance = float(self.distance_var.get())\n            cant = float(self.cant_var.get())\n            radius = float(self.radius_var.get()) if float(self.radius_var.get()) > 0 else 0\n            \n            # Excelå®Œå…¨å†ç¾è¨ˆç®—å®Ÿè¡Œ\n            self.calculation_result = self.excel_calculator.calculate_all_excel_method(distance, height, cant, radius)\n            self.is_calculated = True\n            \n            # çµæœè¡¨ç¤º\n            self.display_results()\n            \n            # ã‚°ãƒ©ãƒ•æ›´æ–°\n            self.update_display()\n            \n        except ValueError:\n            messagebox.showerror(\"å…¥åŠ›ã‚¨ãƒ©ãƒ¼\", \"æ•°å€¤ã‚’æ­£ã—ãå…¥åŠ›ã—ã¦ãã ã•ã„\")\n        except Exception as e:\n            messagebox.showerror(\"è¨ˆç®—ã‚¨ãƒ©ãƒ¼\", f\"è¨ˆç®—ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}\")\n    \n    def display_results(self):\n        \"\"\"çµæœè¡¨ç¤ºï¼ˆV12: OIRANæµ®ãä¸ŠãŒã‚Šé‡ã‚‚è¡¨ç¤ºï¼‰\"\"\"\n        if not self.calculation_result:\n            return\n        \n        result = self.calculation_result\n        self.result_text.delete(1.0, tk.END)\n        \n        # åˆ¤å®šçµæœã‚’æœ€åˆã«å¤§ããè¡¨ç¤º\n        if result['is_interference']:\n            judgment_text = \"âŒ å»ºç¯‰é™ç•ŒæŠµè§¦\\n\"\n            judgment_tag = \"interference_big\"\n        else:\n            judgment_text = \"âœ… å»ºç¯‰é™ç•Œé©åˆ\\n\"\n            judgment_tag = \"safe_big\"\n        \n        self.result_text.insert(tk.END, \"ã€åˆ¤å®šçµæœã€‘\\n\")\n        self.result_text.insert(tk.END, judgment_text)\n        self.result_text.insert(tk.END, \"\\n\")\n        \n        # é‡è¦ãªæ•°å€¤ã‚’ç›®ç«‹ã¤ã‚ˆã†ã«è¡¨ç¤º\n        self.result_text.insert(tk.END, \"ã€é‡è¦ãªæ•°å€¤ã€‘\\n\")\n        self.result_text.insert(tk.END, f\"å¿…è¦é›¢ã‚Œ: {result['required_clearance']:.0f} mm\\n\")\n        \n        # æ”¯éšœæ™‚ã¯é™ç•Œæ”¯éšœé‡ã€é©åˆæ™‚ã¯é™ç•Œä½™è£•ã‚’è¡¨ç¤º\n        if result['is_interference']:\n            self.result_text.insert(tk.END, f\"é™ç•Œæ”¯éšœé‡: {result['clearance_margin']:.0f} mm\\n\")\n        else:\n            self.result_text.insert(tk.END, f\"é™ç•Œä½™è£•: {result['clearance_margin']:.0f} mm\\n\")\n        \n        # V12æ–°æ©Ÿèƒ½: OIRANæµ®ãä¸ŠãŒã‚Šé‡è¡¨ç¤º\n        if result['cant_mm'] > 0:\n            # 1225mmåœ°ç‚¹ã¨1900mmåœ°ç‚¹ã§ã®OIRANæµ®ãä¸ŠãŒã‚Šé‡ã‚’è¡¨ç¤º\n            cant_angle = math.atan(result['cant_mm'] / 1067)\n            oiran_lift_1225 = self.clearance_model.calculate_oiran_lift_amount(1225, 0, result['cant_mm'])\n            oiran_lift_1900 = self.clearance_model.calculate_oiran_lift_amount(1900, 0, result['cant_mm'])\n            \n            self.result_text.insert(tk.END, \"\\nã€OIRANæµ®ãä¸ŠãŒã‚Šé‡ã€‘\\n\")\n            self.result_text.insert(tk.END, f\"1225mmåœ°ç‚¹: {oiran_lift_1225:.1f} mm\\n\")\n            self.result_text.insert(tk.END, f\"1900mmåœ°ç‚¹: {oiran_lift_1900:.1f} mm\\n\")\n        \n        # ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š\n        if result['is_interference']:\n            # æŠµè§¦æ™‚ã¯èµ¤è‰²ã§å¼·èª¿\n            self.result_text.tag_add(\"interference_big\", \"2.0\", \"2.end\")\n            self.result_text.tag_config(\"interference_big\", foreground=\"red\", \n                                      font=(self.default_font[0], self.default_font[1] + 4, \"bold\"))\n            # é‡è¦æ•°å€¤ã‚‚èµ¤è‰²\n            self.result_text.tag_add(\"numbers_red\", \"5.0\", \"end\")\n            self.result_text.tag_config(\"numbers_red\", foreground=\"red\", \n                                      font=(self.default_font[0], self.default_font[1] + 1, \"bold\"))\n        else:\n            # é©åˆæ™‚ã¯ç·‘è‰²ã§å¼·èª¿\n            self.result_text.tag_add(\"safe_big\", \"2.0\", \"2.end\")\n            self.result_text.tag_config(\"safe_big\", foreground=\"green\", \n                                      font=(self.default_font[0], self.default_font[1] + 4, \"bold\"))\n            # é‡è¦æ•°å€¤ã‚‚ç·‘è‰²\n            self.result_text.tag_add(\"numbers_green\", \"5.0\", \"end\")\n            self.result_text.tag_config(\"numbers_green\", foreground=\"green\", \n                                      font=(self.default_font[0], self.default_font[1] + 1, \"bold\"))\n    \n    def update_display(self):\n        \"\"\"è¡¨ç¤ºæ›´æ–°ï¼ˆV12: OIRANæµ®ãä¸ŠãŒã‚Šå¯¾å¿œã‚°ãƒ©ãƒ•è¡¨ç¤ºï¼‰\"\"\"\n        if not self.is_calculated:\n            return\n        \n        result = self.calculation_result\n        \n        # ç¾åœ¨ã®å€¤ã‚’å–å¾—\n        cant = result['cant_mm']\n        radius = result['curve_radius_m'] \n        distance = result['measurement_distance']\n        height = result['measurement_height']\n        \n        self.ax.clear()\n        \n        # ãƒ¬ãƒ¼ãƒ«è¡¨ç¤ºï¼ˆV10ãƒ»V11ã¨åŒã˜ï¼‰\n        rail_gauge = self.clearance_model.rail_gauge\n        self.ax.plot([-rail_gauge/2, rail_gauge/2], [0, 0], \n                    'k-', linewidth=4, label='ãƒ¬ãƒ¼ãƒ«')\n        \n        # å¤‰å½¢å¾Œå»ºç¯‰é™ç•Œè¡¨ç¤ºï¼ˆV12: OIRANæµ®ãä¸ŠãŒã‚Šå¯¾å¿œï¼‰\n        transformed_clearance = self.clearance_model.transform_clearance(self.base_clearance, cant, radius)\n        \n        if transformed_clearance:\n            coords = np.array(transformed_clearance)\n            x_coords = coords[:, 0]\n            y_coords = coords[:, 1]\n            \n            # å»ºç¯‰é™ç•Œã®è‰²è¨­å®šï¼ˆV10ãƒ»V11ã¨åŒã˜ï¼‰\n            if result['is_interference']:\n                color = 'red'\n                label = 'å»ºç¯‰é™ç•Œï¼ˆæ”¯éšœï¼‰'\n            else:\n                color = 'blue'\n                label = 'å»ºç¯‰é™ç•Œï¼ˆå®‰å…¨ï¼‰'\n            \n            # å»ºç¯‰é™ç•Œå¡—ã‚Šã¤ã¶ã—ã¨è¼ªéƒ­\n            self.ax.fill(x_coords, y_coords, alpha=0.3, color=color)\n            self.ax.plot(x_coords, y_coords, color=color, linewidth=2, label=label)\n        \n        # æ¸¬å®šç‚¹è¡¨ç¤ºï¼ˆå…¥åŠ›åº§æ¨™ã‚’ãã®ã¾ã¾ä½¿ç”¨ã€V10ãƒ»V11ã¨åŒã˜ï¼‰\n        if distance > 0:\n            actual_measurement_x = -abs(distance)  # æ­£ã®å€¤ã¯å·¦å´ï¼ˆè² ã®åº§æ¨™ï¼‰\n        else:\n            actual_measurement_x = abs(distance)   # è² ã®å€¤ã¯å³å´ï¼ˆæ­£ã®åº§æ¨™ï¼‰\n        \n        self.ax.plot(actual_measurement_x, height, 'ro', markersize=6, label='æ¸¬å®šç‚¹')\n        \n        # æœ€çŸ­è·é›¢ç·šè¡¨ç¤ºï¼ˆæ”¯éšœæ™‚ã‚‚é©åˆæ™‚ã‚‚åŒã˜æœ€çŸ­è·é›¢ã®è¨ˆç®—ï¼‰\n        if transformed_clearance:\n            min_distance = float('inf')\n            closest_point = None\n            \n            for clearance_x, clearance_y in transformed_clearance:\n                # æ¸¬å®šç‚¹ã¨ã®è·é›¢è¨ˆç®—\n                dx = actual_measurement_x - clearance_x\n                dy = height - clearance_y\n                distance_to_point = math.sqrt(dx**2 + dy**2)\n                \n                if distance_to_point < min_distance:\n                    min_distance = distance_to_point\n                    closest_point = (clearance_x, clearance_y)\n            \n            # æœ€çŸ­è·é›¢ç·šã‚’ç·‘ã®ç‚¹ç·šã§è¡¨ç¤ºï¼ˆæ”¯éšœæ™‚ã¯é™ç•Œæ”¯éšœé‡ã€é©åˆæ™‚ã¯é™ç•Œä½™è£•ï¼‰\n            if closest_point:\n                if result['is_interference']:\n                    label_text = f'é™ç•Œæ”¯éšœé‡: {result[\"clearance_margin\"]}mm'\n                else:\n                    label_text = f'é™ç•Œä½™è£•: {result[\"clearance_margin\"]}mm'\n                \n                self.ax.plot([actual_measurement_x, closest_point[0]], \n                           [height, closest_point[1]], \n                           'g--', linewidth=2, label=label_text)\n                # æœ€è¿‘ç‚¹ã‚’ãƒãƒ¼ã‚¯ï¼ˆå°ã•ãï¼‰\n                self.ax.plot(closest_point[0], closest_point[1], 'go', markersize=4)\n        \n        # V12æ–°æ©Ÿèƒ½: OIRANæµ®ãä¸ŠãŒã‚Šé‡ã®å¯è¦–åŒ–\n        if cant > 0:\n            # 1225mmåœ°ç‚¹ã¨1900mmåœ°ç‚¹ã§ã®OIRANæµ®ãä¸ŠãŒã‚Šé‡ã‚’è¡¨ç¤º\n            oiran_lift_1225 = self.clearance_model.calculate_oiran_lift_amount(1225, 0, cant)\n            oiran_lift_1900 = self.clearance_model.calculate_oiran_lift_amount(1900, 0, cant)\n            \n            # OIRANæµ®ãä¸ŠãŒã‚Šé‡ã‚’ç¤ºã™ãƒ©ã‚¤ãƒ³\n            self.ax.plot([-1225, -1225], [0, oiran_lift_1225], 'r:', linewidth=2, \n                        label=f'OIRANæµ®ä¸Š1225mm: {oiran_lift_1225:.1f}mm')\n            self.ax.plot([1900, 1900], [0, oiran_lift_1900], 'r:', linewidth=2, \n                        label=f'OIRANæµ®ä¸Š1900mm: {oiran_lift_1900:.1f}mm')\n            \n            # æµ®ãä¸ŠãŒã‚Šé‡ã®ãƒãƒ¼ã‚«ãƒ¼\n            self.ax.plot(-1225, oiran_lift_1225, 'ro', markersize=4)\n            self.ax.plot(1900, oiran_lift_1900, 'ro', markersize=4)\n        \n        # ã‚°ãƒ©ãƒ•è¨­å®šï¼ˆV10ãƒ»V11ã¨åŒã˜ï¼‰\n        self.ax.grid(True, alpha=0.3)\n        self.ax.set_xlabel('é›¢ã‚Œ (mm)', fontsize=12)\n        self.ax.set_ylabel('é«˜ã• (mm)', fontsize=12)\n        self.ax.set_title('å»ºç¯‰é™ç•Œã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ v12.0 OIRAN Exact', fontsize=14)\n        \n        # è¡¨ç¤ºç¯„å›²\n        try:\n            distance_value = abs(distance)\n            x_max = max(3000, distance_value + 1000)\n        except:\n            x_max = 3000\n        self.ax.set_xlim(-x_max, x_max)\n        self.ax.set_ylim(-500, 6000)\n        \n        # å‡¡ä¾‹\n        self.ax.legend(loc='upper right')\n        \n        # æç”»æ›´æ–°\n        self.canvas.draw()\n    \n    def reset_values(self):\n        \"\"\"å€¤ãƒªã‚»ãƒƒãƒˆï¼ˆV10ãƒ»V11ã¨åŒã˜ï¼‰\"\"\"\n        self.distance_var.set(\"0\")\n        self.height_var.set(\"0\")\n        self.cant_var.set(\"0\")\n        self.radius_var.set(\"0\")\n        self.result_text.delete(1.0, tk.END)\n        self.calculation_result = None\n        self.is_calculated = False\n        self.setup_initial_graph()\n    \n    def run(self):\n        \"\"\"ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å®Ÿè¡Œ\"\"\"\n        self.root.mainloop()\n\n\ndef main():\n    \"\"\"ãƒ¡ã‚¤ãƒ³é–¢æ•°\"\"\"\n    app = ClearanceAppV12OIRANExactUI()\n    app.run()\n\n\nif __name__ == \"__main__\":\n    main()